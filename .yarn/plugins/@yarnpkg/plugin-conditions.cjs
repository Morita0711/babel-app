/* eslint-disable */
module.exports = {
name: "@yarnpkg/plugin-conditions",
factory: function (require) {
var plugin;plugin=(()=>{"use strict";var e={973:(e,t,n)=>{n.r(t),n.d(t,{default:()=>b});const o=require("@yarnpkg/core");function r(e){return e.startsWith("condition:")}function i(e){const t=e.match(/^condition:\s*(?<test>\w+)\s*\?\s*(?<consequent>[^\s:]*)\s*:\s*(?<alternate>[^\s:#]*)\s*(?:#(.*))?$/);let n;n=null!==t?t.groups:o.structUtils.parseRange(e).params;const{test:r,consequent:i,alternate:s}=n;return{test:r,consequent:i||null,alternate:s||null}}function s(e){return i(e.range)}function a(e){return i(e.reference)}function c({test:e,consequent:t,alternate:n,hash:o}){return`condition:${e}?${t||""}:${n||""}#${o||""}`}function u(e,{test:t,consequent:n,alternate:r,hash:i}){return o.structUtils.makeLocator(e,c({test:t,consequent:n,alternate:r,hash:i}))}function l(e,t,n,r,i){const s=o.structUtils.makeIdent(t.scope,`${t.name}-${n}-${i}`),a=e.configuration.get("defaultProtocol")+`${o.structUtils.stringifyIdent(t)}@${r}`;return o.structUtils.makeDescriptor(s,a)}function p(e,t,n,r){return o.hashUtils.makeHash(String(3),e,t||"-",n||"-",r?"1":"0").slice(0,6)}const d={conditions:{description:"",type:o.SettingsType.MAP,valueDefinition:{description:"",type:o.SettingsType.SHAPE,properties:{source:{description:"",type:o.SettingsType.STRING,default:"env"},default:{description:"",type:o.SettingsType.BOOLEAN,default:!1}}}}};function f(e,t){if(!e.configuration.get("conditions").has(t))throw new Error(`Unknown condition: ${t}. You must add it to your .yarnrc.yml file.`)}function g(e,t){return f(e,t),e.configuration.get("conditions").get(t).get("default")}function h(e,t){var n;f(e,t);const o=e.configuration.get("conditions").get(t),r=o.get("source"),i=o.get("default");if("env"!==r)throw new Error("The only supported configuration source is 'env'");return null!==(n=(s=process.env[t])&&"false"!==s&&"0"!==s)&&void 0!==n?n:i;var s}const y=require("@yarnpkg/fslib"),m=require("@yarnpkg/libzip");const v=["dependencies","devDependencies","peerDependencies"];const w=require("@yarnpkg/cli"),k=require("clipanion");var P=function(e,t,n,o){var r,i=arguments.length,s=i<3?t:null===o?o=Object.getOwnPropertyDescriptor(t,n):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,o);else for(var a=e.length-1;a>=0;a--)(r=e[a])&&(s=(i<3?r(s):i>3?r(t,n,s):r(t,n))||s);return i>3&&s&&Object.defineProperty(t,n,s),s};class j extends w.BaseCommand{async execute(){if(this.false&&this.true)throw new Error("You can either specify --true or --false");const{project:e,workspace:t,cache:n,configuration:r}=await this.getRoot();f(e,this.condition);const i=!this.false&&(!!this.true||h(e,this.condition));for(const n of this.nestedWorkspaces(t,e))this.materializeCondition(i,n);const s=await o.StreamReport.start({configuration:r,stdout:this.context.stdout,includeLogs:!0},async t=>{await e.resolveEverything({cache:n,report:t})});if(s.hasErrors())return s.exitCode();await e.persist()}*nestedWorkspaces(e,t){yield e;for(const n of e.workspacesCwds){const e=t.workspacesByCwd.get(n);e&&(yield*this.nestedWorkspaces(e,t))}}materializeCondition(e,t){for(const n of v){const i=t.manifest.getForScope(n).values();for(const a of i){if(!r(a.range))continue;const{test:i,consequent:c,alternate:u}=s(a);if(i!==this.condition)continue;const l=e?c:u;l?t.manifest[n].set(a.identHash,o.structUtils.makeDescriptor(a,l)):t.manifest[n].delete(a.identHash)}}}async getRoot(){const e=await o.Configuration.find(this.context.cwd,this.context.plugins),[{project:t,workspace:n},r]=await Promise.all([o.Project.find(e,this.context.cwd),o.Cache.find(e,{immutable:!0})]);return{configuration:e,project:t,workspace:n,cache:r}}}j.usage=k.Command.Usage({description:"Evaluate and replace a condition in package.json files",details:"\n      This command will replace all the occurrences of `<condition>` in the current workspace and in nested workspaces.\n\n      The value of the condition (`true` or `false`) is based on the following sources, in descending priority order:\n\n      - the `--true` or `--false` option;\n      - the `<condition>` environment variable;\n      - the default value specified in the Yarn configuration;\n      - `false` by default.\n    "}),P([k.Command.String({required:!0})],j.prototype,"condition",void 0),P([k.Command.Boolean("--true")],j.prototype,"true",void 0),P([k.Command.Boolean("--false")],j.prototype,"false",void 0),P([k.Command.Path("condition","materialize")],j.prototype,"execute",null);const b={configuration:d,commands:[j],fetchers:[class{supports(e){return r(e.reference)}getLocalPath(){return null}async fetch(e,t){const n=t.checksums.get(e.locatorHash)||null,[r,i,s]=await t.cache.fetchPackageFromCache(e,n,{onHit:()=>t.report.reportCacheHit(e),onMiss:()=>t.report.reportCacheMiss(e,o.structUtils.prettyLocator(t.project.configuration,e)+" can't be found in the cache and will be fetched from the disk"),loader:()=>this.generateConditionPackage(e,t),skipIntegrityCheck:t.skipIntegrityCheck});return{packageFs:r,releaseFs:i,prefixPath:o.structUtils.getIdentVendorPath(e),localPath:this.getLocalPath(),checksum:s}}async generateConditionPackage(e,t){const{test:n,consequent:r,alternate:i}=a(e),s=g(t.project,n),c=p(n,r,i,s),u=(r,i)=>{if(null==r)return{dependency:null,specifier:JSON.stringify("ASSERT: Missing dependency")};const s=l(t.project,e,n,r,i),a=o.structUtils.stringifyIdent(s);return{dependency:{[a]:s.range},specifier:JSON.stringify(a)}},d=u(r,!0),f=u(i,!1);return async function(e,t,n,r){const[i,s]=await Promise.all([y.xfs.mktempPromise(),(0,m.getLibzipPromise)()]),a=y.ppath.join(i,"condition.zip"),c=o.structUtils.getIdentVendorPath(e),u=new y.ZipFS(a,{libzip:s,create:!0,level:t.configuration.get("compressionLevel")});return await u.mkdirpPromise(c),await Promise.all([u.writeJsonPromise(y.ppath.join(c,"package.json"),n),u.writeFilePromise(y.ppath.join(c,"index.js"),r)]),await Promise.all(u.getAllFiles().map(e=>u.utimesPromise(e,15805116e5,15805116e5))),u}(e,t.project,{version:"0.0.0-condition-"+c,dependencies:{...d.dependency,...f.dependency}},`// env vars from the cli are always strings, so !!ENV_VAR returns true for "false"\nfunction bool(value) {\n  if (value == null) return ${s};\n  return value && value !== "false" && value !== "0";\n}\nmodule.exports = bool(process.env[${JSON.stringify(n)}])\n  ? require(${d.specifier})\n  : require(${f.specifier});\n`)}}],resolvers:[class{supportsDescriptor(e){return r(e.range)}supportsLocator(e){return r(e.reference)}shouldPersistResolution(){return!1}bindDescriptor(e){return e}getResolutionDependencies(e,t){const{test:n,consequent:o,alternate:r}=s(e);return[o&&l(t.project,e,n,o,!0),r&&l(t.project,e,n,r,!1)].filter(Boolean)}async getCandidates(e,t,n){const{test:o,consequent:r,alternate:i}=s(e);return[u(e,{test:o,consequent:r,alternate:i,hash:p(o,r,i,g(n.project,o))})]}async getSatisfying(){return null}async resolve(e,t){const{test:n,consequent:r,alternate:i}=a(e),s=p(n,r,i,g(t.project,n)),c=r&&l(t.project,e,n,r,!0),u=i&&l(t.project,e,n,i,!1);return{...e,version:"0.0.0-condition-"+s,languageName:t.project.configuration.get("defaultLanguageName"),linkType:o.LinkType.HARD,dependencies:new Map([r&&[c.identHash,c],i&&[u.identHash,u]].filter(Boolean)),peerDependencies:new Map,dependenciesMeta:new Map,peerDependenciesMeta:new Map,bin:null}}}],hooks:{beforeWorkspacePacking:function(e,t){var n;const{project:i}=e;for(const a of v){const c=e.manifest.getForScope(a).values();for(const e of c){if(!r(e.range))continue;const{test:c,consequent:u,alternate:l}=s(e),p=h(i,c)?u:l,d=o.structUtils.stringifyIdent(e),f="dependencies"===a&&!t.dependencies[d]&&(null===(n=t.optionalDependencies)||void 0===n?void 0:n[d])?"optionalDependencies":a;p?t[f][d]=p:delete t[f][d]}}}}}}},t={};function n(o){if(t[o])return t[o].exports;var r=t[o]={exports:{}};return e[o](r,r.exports,n),r.exports}return n.d=(e,t)=>{for(var o in t)n.o(t,o)&&!n.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:t[o]})},n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),n.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n(973)})();
return plugin;
}
};