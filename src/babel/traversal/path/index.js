import PathHoister from "./lib/hoister";
import * as virtualTypes from "./lib/virtual-types";
import * as messages from "../../messages";
import * as contextual from "./lib/contextual";
import isBoolean from "lodash/lang/isBoolean";
import isNumber from "lodash/lang/isNumber";
import isRegExp from "lodash/lang/isRegExp";
import isString from "lodash/lang/isString";
import codeFrame from "../../helpers/code-frame";
import parse from "../../helpers/parse";
import { explode } from "../visitors";
import traverse from "../index";
import includes from "lodash/collection/includes";
import assign from "lodash/object/assign";
import extend from "lodash/object/extend";
import Scope from "../scope";
import * as t from "../../types";

export default class NodePath {
  constructor(parent, container) {
    this.container = container;
    this.contexts  = [];
    this.parent    = parent;
    this.data      = {};
  }

  /**
   * Description
   */

  static get(parentPath: NodePath, parent, container, key) {
    var targetNode = container[key];
    var paths = container._paths = container._paths || [];
    var path;

    for (var i = 0; i < paths.length; i++) {
      var pathCheck = paths[i];
      if (pathCheck.node === targetNode) {
        path = pathCheck;
        break;
      }
    }

    if (!path) {
      path = new NodePath(parent, container);
      paths.push(path);
    }

    path.setup(parentPath, key);

    return path;
  }

  /**
   * Description
   */

  static getScope(path: NodePath, scope: Scope, file?: File) {
    var ourScope = scope;

    // we're entering a new scope so let's construct it!
    if (path.isScope()) {
      ourScope = new Scope(path, scope, file);
    }

    return ourScope;
  }

  /**
   * Check whether this node was a part of the original AST.
   */

  isUser() {
    return this.node && !!this.node.loc;
  }

  /**
   * Check whether this node was generated by us and not a part of the original AST.
   */

  isGenerated() {
    return !this.isUser();
  }

  /**
   * Description
   */

  queueNode(path) {
    for (var context of (this.contexts: Array)) {
      if (context.queue) {
        context.queue.push(path);
      }
    }
  }

  /**
   * Description
   */

  insertBefore(nodes) {
    nodes = this._verifyNodeList(nodes);

    if (this.parentPath.isExpressionStatement() || this.parentPath.isLabeledStatement()) {
      return this.parentPath.insertBefore(nodes);
    } else if (this.isPreviousType("Expression") || (this.parentPath.isForStatement() && this.key === "init")) {
      if (this.node) nodes.push(this.node);
      this.replaceExpressionWithStatements(nodes);
    } else if (this.isPreviousType("Statement") || !this.type) {
      this._maybePopFromStatements(nodes);
      if (Array.isArray(this.container)) {
        this._containerInsertBefore(nodes);
      } else if (this.isStatementOrBlock()) {
        if (this.node) nodes.push(this.node);
        this.node = this.container[this.key] = t.blockStatement(nodes);
      } else {
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
      }
    } else {
      throw new Error("No clue what to do with this node type.");
    }
  }

  _containerInsert(from, nodes) {
    this.updateSiblingKeys(from, nodes.length);

    var paths = [];

    for (var i = 0; i < nodes.length; i++) {
      var to = from + i;
      var node = nodes[i];
      this.container.splice(to, 0, node);

      if (this.context) {
        var path = this.context.create(this.parent, this.container, to);
        paths.push(path);
        this.queueNode(path);
      } else {
        paths.push(NodePath.get(this, node, this.container, to));
      }
    }

    return paths;
  }

  _containerInsertBefore(nodes) {
    return this._containerInsert(this.key, nodes);
  }

  _containerInsertAfter(nodes) {
    return this._containerInsert(this.key + 1, nodes);
  }

  _maybePopFromStatements(nodes) {
    var last = nodes[nodes.length - 1];
    if (t.isExpressionStatement(last) && t.isIdentifier(last.expression) && !this.isCompletionRecord()) {
      nodes.pop();
    }
  }

  /**
   * Description
   */

  isCompletionRecord() {
    var path = this;

    do {
      var container = path.container;

      if (path.isFunction()) {
        return false;
      }

      if (Array.isArray(container) && path.key !== container.length - 1) {
        return false;
      }
    } while ((path = path.parentPath) && !path.isProgram());

    return true;
  }

  /**
   * Description
   */

  isStatementOrBlock() {
    if (t.isLabeledStatement(this.parent) || t.isBlockStatement(this.container)) {
      return false;
    } else {
      return includes(t.STATEMENT_OR_BLOCK_KEYS, this.key);
    }
  }

  /**
   * Description
   */

  insertAfter(nodes) {
    nodes = this._verifyNodeList(nodes);

    if (this.parentPath.isExpressionStatement() || this.parentPath.isLabeledStatement()) {
      return this.parentPath.insertAfter(nodes);
    } else if (this.isPreviousType("Expression") || (this.parentPath.isForStatement() && this.key === "init")) {
      if (this.node) {
        var temp = this.scope.generateDeclaredUidIdentifier();
        nodes.unshift(t.expressionStatement(t.assignmentExpression("=", temp, this.node)));
        nodes.push(t.expressionStatement(temp));
      }
      this.replaceExpressionWithStatements(nodes);
    } else if (this.isPreviousType("Statement") || !this.type) {
      this._maybePopFromStatements(nodes);
      if (Array.isArray(this.container)) {
        this._containerInsertAfter(nodes);
      } else if (this.isStatementOrBlock()) {
        if (this.node) nodes.unshift(this.node);
        this.node = this.container[this.key] = t.blockStatement(nodes);
      } else {
        throw new Error("We don't know what to do with this node type. We were previously a Statement but we can't fit in here?");
      }
    } else {
      throw new Error("No clue what to do with this node type.");
    }
  }

  /**
   * Description
   */

  updateSiblingKeys(fromIndex, incrementBy) {
    var paths = this.container._paths;
    for (var i = 0; i < paths.length; i++) {
      let path = paths[i];
      if (path.key >= fromIndex) {
        path.key += incrementBy;
      }
    }
  }

  /**
   * Description
   */

  setData(key, val) {
    return this.data[key] = val;
  }

  /**
   * Description
   */

  getData(key, def) {
    var val = this.data[key];
    if (!val && def) val = this.data[key] = def;
    return val;
  }

  /**
   * Description
   */

  setScope(file?) {
    if (this.opts && this.opts.noScope) return;

    var target = this.context || this.parentPath;
    this.scope = NodePath.getScope(this, target && target.scope, file);
  }

  /**
   * Description
   */

  setContext(context, file) {
    this.shouldSkip = false;
    this.shouldStop = false;
    this.removed    = false;

    if (context) {
      this.context = context;
      this.state   = context.state;
      this.opts    = context.opts;
    }

    var log = file && this.type === "Program";
    if (log) file.log.debug("Start scope building");
    this.setScope(file);
    if (log) file.log.debug("End scope building");

    return this;
  }

  /**
   * Description
   */

  update() {
    if (this.node === this.container[this.key]) return;

    // grrr, path key is out of sync. this is likely due to a modification to the AST
    // not through our path APIs

    if (Array.isArray(this.container)) {
      for (var i = 0; i < this.container.length; i++) {
        if (this.container[i] === this.node) {
          return this.setKey(i);
        }
      }
    } else {
      for (var key in this.container) {
        if (this.container[key] === this.node) {
          return this.setKey(key);
        }
      }
    }

    throw new Error(messages.get("lostTrackNodePath"));
  }

  /**
   * Description
   */

  shiftContext() {
    this.contexts.shift();
    this.setContext(this.contexts[0]);
  }

  /**
   * Description
   */

  unshiftContext(context) {
    this.contexts.unshift(context);
    this.setContext(context);
  }

  /**
   * Description
   */

  setup(parentPath, key) {
    this.parentPath = parentPath || this.parentPath;
    this.setKey(key);
  }

  /**
   * Description
   */

  setKey(key) {
    this.key  = key;
    this.node = this.container[this.key];
    this.type = this.node && this.node.type;
  }

  /**
   * Share comments amongst siblings.
   */

  shareCommentsWithSiblings() {
    var node = this.node;
    if (!node) return;

    var trailing = node.trailingComments;
    var leading  = node.leadingComments;
    if (!trailing && !leading) return;

    var prev = this.getSibling(this.key - 1);
    var next = this.getSibling(this.key + 1);

    if (!prev.node) prev = next;
    if (!next.node) next = prev;

    prev.giveComments("trailing", leading);
    next.giveComments("leading", trailing);
  }

  /**
   * Give node `comments` of the specified `type`.
   */

  giveComments(type: string, comments: Array) {
    if (!comments) return;

    var node = this.node;
    if (!node) return;

    var key = `${type}Comments`;

    if (node[key]) {
      node[key] = node[key].concat(comments);
    } else {
      node[key] = comments;
    }
  }

  /**
   * Description
   */

  remove() {
    if (this._contextualCall("removers", "pre")) return;

    this.shareCommentsWithSiblings();
    this._remove();
    this.removed = true;

    this._contextualCall("removers", "post");
  }

  _contextualCall(type, position) {
    for (var fn of (contextual[type][position]: Array)) {
      if (fn(this, this.parentPath)) return;
    }
  }

  _remove() {
    if (Array.isArray(this.container)) {
      this.container.splice(this.key, 1);
      this.updateSiblingKeys(this.key, -1);
    } else {
      this.container[this.key] = null;
    }
    this.node = null;
  }

  /**
   * Description
   */

  skip() {
    this.shouldSkip = true;
  }

  /**
   * Description
   */

  stop() {
    this.shouldStop = true;
    this.shouldSkip = true;
  }

  /**
   * Description
   */

  errorWithNode(msg, Error = SyntaxError) {
    var loc = this.node.loc.start;
    var err = new Error(`Line ${loc.line}: ${msg}`);
    err.loc = loc;
    return err;
  }

  /**
   * Description
   */

  _verifyNodeList(nodes) {
    if (nodes.constructor !== Array) {
      nodes = [nodes];
    }

    for (var i = 0; i < nodes.length; i++) {
      var node = nodes[i];
      if (!node) {
        throw new Error(`Node list has falsy node with the index of ${i}`);
      } else if (typeof node !== "object") {
        throw new Error(`Node list contains a non-object node with the index of ${i}`);
      } else if (!node.type) {
        throw new Error(`Node list contains a node without a type with the index of ${i}`);
      }
    }

    return nodes;
  }

  /**
   * Description
   */

  unshiftContainer(containerKey, nodes) {
    nodes = this._verifyNodeList(nodes);

    // get the first path and insert our nodes before it, if it doesn't exist then it
    // doesn't matter, our nodes will be inserted anyway

    var container = this.node[containerKey];
    var path      = NodePath.get(this, this.node, container, 0);

    return path.insertBefore(nodes);
  }

  /**
   * Description
   */

  pushContainer(containerKey, nodes) {
    nodes = this._verifyNodeList(nodes);

    // get an invisible path that represents the last node + 1 and replace it with our
    // nodes, effectively inlining it

    var container = this.node[containerKey];
    var i         = container.length;
    var path      = NodePath.get(this, this.node, container, i);

    return path.replaceWith(nodes, true);
  }

  /**
   * This checks whether or now we're in one of the following positions:
   *
   *   for (KEY in right);
   *   for (KEY;;);
   *
   * This is because these spots allow VariableDeclarations AND normal expressions so we need to tell the
   * path replacement that it's ok to replace this with an expression.
   */

   canHaveVariableDeclarationOrExpression() {
      return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
   }

  /**
   * Description
   */

  getStatementParent(): ?NodePath {
    var path = this;

    do {
      if (!path.parentPath || (Array.isArray(path.container) && path.isStatement())) {
        break;
      } else {
        path = path.parentPath;
      }
    } while (path);

    if (path && (path.isProgram() || path.isFile())) {
      throw new Error("File/Program node, we can't possibly find a statement parent to this");
    }

    return path;
  }

  /**
   * Description
   */

  getCompletionRecords(): Array<NodePath> {
    var paths = [];

    var add = function (path) {
      if (path) paths = paths.concat(path.getCompletionRecords());
    };

    if (this.isIfStatement()) {
      add(this.get("consequent"));
      add(this.get("alternate"));
    } else if (this.isDoExpression() || this.isFor() || this.isWhile()) {
      add(this.get("body"));
    } else if (this.isProgram() || this.isBlockStatement()) {
      add(this.get("body").pop());
    } else if (this.isFunction()) {
      return this.get("body").getCompletionRecords();
    } else {
      paths.push(this);
    }

    return paths;
  }


  /**
   * Description
   */

  call(key) {
    var node = this.node;
    if (!node) return;

    var opts = this.opts;
    if (!opts[key] && !opts[node.type]) return;

    var fns = [].concat(opts[key]);
    if (opts[node.type]) fns = fns.concat(opts[node.type][key]);

    for (var fn of (fns: Array)) {
      if (!fn) continue;

      let node = this.node;
      if (!node) return;

      var previousType = this.type;

      // call the function with the params (node, parent, scope, state)
      var replacement = fn.call(this, node, this.parent, this.scope, this.state);

      if (replacement) {
        this.replaceWith(replacement, true);
      }

      if (this.shouldStop || this.shouldSkip || this.removed) return;

      if (previousType !== this.type) {
        this.queueNode(this);
        return;
      }
    }
  }

  /**
   * Description
   */

  isBlacklisted(): boolean {
    var blacklist = this.opts.blacklist;
    return blacklist && blacklist.indexOf(this.node.type) > -1;
  }

  /**
   * Description
   */

  visit(): boolean {
    if (this.isBlacklisted()) return false;
    if (this.opts.shouldSkip && this.opts.shouldSkip(this)) return false;

    this.call("enter");

    if (this.shouldSkip) {
      return this.shouldStop;
    }

    var node = this.node;
    var opts = this.opts;

    if (node) {
      if (Array.isArray(node)) {
        // traverse over these replacement nodes we purposely don't call exitNode
        // as the original node has been destroyed
        for (var i = 0; i < node.length; i++) {
          traverse.node(node[i], opts, this.scope, this.state, this);
        }
      } else {
        traverse.node(node, opts, this.scope, this.state, this);
        this.call("exit");
      }
    }

    return this.shouldStop;
  }

  /**
   * Description
   */

  getSibling(key) {
    return NodePath.get(this.parentPath, this.parent, this.container, key, this.file);
  }

  /**
   * Description
   */

  get(key: string): NodePath {
    var parts = key.split(".");
    if (parts.length === 1) { // "foo"
      return this._getKey(key);
    } else { // "foo.bar"
      return this._getPattern(parts);
    }
  }

  /**
   * Description
   */

  _getKey(key) {
    var node      = this.node;
    var container = node[key];

    if (Array.isArray(container)) {
      // requested a container so give them all the paths
      return container.map((_, i) => {
        return NodePath.get(this, node, container, i).setContext();
      });
    } else {
      return NodePath.get(this, node, node, key).setContext();
    }
  }

  /**
   * Description
   */

  _getPattern(parts) {
    var path = this;
    for (var part of (parts: Array)) {
      if (part === ".") {
        path = path.parentPath;
      } else {
        if (Array.isArray(path)) {
          path = path[part];
        } else {
          path = path.get(part);
        }
      }
    }
    return path;
  }

  /**
   * Description
   */

  has(key): boolean {
    var val = this.node[key];
    if (val && Array.isArray(val)) {
      return !!val.length;
    } else {
      return !!val;
    }
  }

  /**
   * Description
   */

  is(key): boolean {
    return this.has(key);
  }

  /**
   * Description
   */

  isnt(key): boolean {
    return !this.has(key);
  }

  /**
   * Description
   */

  equals(key, value): boolean {
    return this.node[key] === value;
  }

  /**
   * Description
   */

  isPreviousType(type: string): boolean {
    return t.isType(this.type, type);
  }

  /**
   * Description
   */

  getBindingIdentifiers() {
    return t.getBindingIdentifiers(this.node);
  }

  /**
   * Description
   */

  traverse(visitor, state) {
    if (!this.scope) console.log(this.contexts);
    traverse(this.node, visitor, this.scope, state, this);
  }

  /**
   * Description
   */

  hoist(scope = this.scope) {
    var hoister = new PathHoister(this, scope);
    return hoister.run();
  }

  /**
   * Match the current node if it matches the provided `pattern`.
   *
   * For example, given the match `React.createClass` it would match the
   * parsed nodes of `React.createClass` and `React["createClass"]`.
   */

  matchesPattern(pattern: string, allowPartial?: boolean): boolean {
   var parts = pattern.split(".");

    // not a member expression
    if (!this.isMemberExpression()) return false;

    var search = [this.node];
    var i = 0;

    function matches(name) {
      var part = parts[i];
      return part === "*" || name === part;
    }

    while (search.length) {
      var node = search.shift();

      if (allowPartial && i === parts.length) {
        return true;
      }

      if (t.isIdentifier(node)) {
        // this part doesn't match
        if (!matches(node.name)) return false;
      } else if (t.isLiteral(node)) {
        // this part doesn't match
        if (!matches(node.value)) return false;
      } else if (t.isMemberExpression(node)) {
        if (node.computed && !t.isLiteral(node.property)) {
          // we can't deal with this
          return false;
        } else {
          search.push(node.object);
          search.push(node.property);
          continue;
        }
      } else {
        // we can't deal with this
        return false;
      }

      // too many parts
      if (++i > parts.length) {
        return false;
      }
    }

    return true;
  }
}

assign(NodePath.prototype, require("./ancestry"));
assign(NodePath.prototype, require("./resolution"));
assign(NodePath.prototype, require("./replacement"));
assign(NodePath.prototype, require("./evaluation"));
assign(NodePath.prototype, require("./conversion"));

for (let type in virtualTypes) {
  if (type[0] === "_") continue;

  NodePath.prototype[`is${type}`] = function (opts) {
    return virtualTypes[type].checkPath(this, opts);
  };
}

for (let type of (t.TYPES: Array)) {
  let typeKey = `is${type}`;
  NodePath.prototype[typeKey] = function (opts) {
    return t[typeKey](this.node, opts);
  };
}
