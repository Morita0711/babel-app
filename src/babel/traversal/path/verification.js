import includes from "lodash/collection/includes";
import * as t from "../../types";

/**
 * Match the current node if it matches the provided `pattern`.
 *
 * For example, given the match `React.createClass` it would match the
 * parsed nodes of `React.createClass` and `React["createClass"]`.
 */

export function matchesPattern(pattern: string, allowPartial?: boolean): boolean {
 var parts = pattern.split(".");

  // not a member expression
  if (!this.isMemberExpression()) return false;

  var search = [this.node];
  var i = 0;

  function matches(name) {
    var part = parts[i];
    return part === "*" || name === part;
  }

  while (search.length) {
    var node = search.shift();

    if (allowPartial && i === parts.length) {
      return true;
    }

    if (t.isIdentifier(node)) {
      // this part doesn't match
      if (!matches(node.name)) return false;
    } else if (t.isLiteral(node)) {
      // this part doesn't match
      if (!matches(node.value)) return false;
    } else if (t.isMemberExpression(node)) {
      if (node.computed && !t.isLiteral(node.property)) {
        // we can't deal with this
        return false;
      } else {
        search.push(node.object);
        search.push(node.property);
        continue;
      }
    } else {
      // we can't deal with this
      return false;
    }

    // too many parts
    if (++i > parts.length) {
      return false;
    }
  }

  return true;
}

/**
 * Description
 */

export function has(key): boolean {
  var val = this.node[key];
  if (val && Array.isArray(val)) {
    return !!val.length;
  } else {
    return !!val;
  }
}

/**
 * Description
 */

export function is(key): boolean {
  return this.has(key);
}

/**
 * Description
 */

export function isnt(key): boolean {
  return !this.has(key);
}

/**
 * Description
 */

export function equals(key, value): boolean {
  return this.node[key] === value;
}

/**
 * Description
 */

export function isPreviousType(type: string): boolean {
  return t.isType(this.type, type);
}

/**
 * This checks whether or now we're in one of the following positions:
 *
 *   for (KEY in right);
 *   for (KEY;;);
 *
 * This is because these spots allow VariableDeclarations AND normal expressions so we need to tell the
 * path replacement that it's ok to replace this with an expression.
 */

 export function canHaveVariableDeclarationOrExpression() {
    return (this.key === "init" || this.key === "left") && this.parentPath.isFor();
 }

/**
 * Description
 */

export function isCompletionRecord() {
  var path = this;

  do {
    var container = path.container;

    if (path.isFunction()) {
      return false;
    }

    if (Array.isArray(container) && path.key !== container.length - 1) {
      return false;
    }
  } while ((path = path.parentPath) && !path.isProgram());

  return true;
}

/**
 * Description
 */

export function isStatementOrBlock() {
  if (t.isLabeledStatement(this.parent) || t.isBlockStatement(this.container)) {
    return false;
  } else {
    return includes(t.STATEMENT_OR_BLOCK_KEYS, this.key);
  }
}

/**
 * Check whether this node was a part of the original AST.
 */

export function isUser() {
  return this.node && !!this.node.loc;
}

/**
 * Check whether this node was generated by us and not a part of the original AST.
 */

export function isGenerated() {
  return !this.isUser();
}
